/*
statements are terminated by newline. To continue a statement, put a "\" as the first non-whitespace character on a line.
No need for package, super, type facets.
No need for "function" keyword.
*/

//Source consists of "package", "use", "public", "private". All are optional.
//If package isn't specified, its a configuration file.

package: "youni.works/base/control"

use: {
	//Generally, you don't specify the version.  It is added by the compiler.
	system: "youni.works/base/system?20123"
}

public: {
	Control: Object {
		controller: Controller
		part: Part
		receive: (message) {
			this.controller.process(this, message)
		}
	}
	Controller: Control {
		use: {
			Part: Record
		}
		log: console
		process: (on, message) {
			let action = message.action
			while (action) try {
				this.execute(on, message)
				action = (message.action == action ? "" : message.action)
			} catch (fault) {
				this.trap(on, message, fault)
			}
		}
		execute: (on, message) {
			let method = on[message.action]
			if (typeof method == "function") {
				method[message.length ? "apply" : "call"](on, message)
			}
		}
		trap: (on, message, fault) {
			fault.message = `Error processing action "${message.action}": ` + fault.message
			fault.processing = message
			fault.on = on
			throw fault
		}
		initialize: (conf) {
			if (!this.part[Symbol.iterator]) {
				this.sys.define(this.part, Symbol.iterator, this.use.Part[Symbol.iterator], "const")
			}
			for (let part of this.part) part.partOf = this
		}
		super: (method, ...args) {
			let object = this
			if (this[method]) while (object = this.sys.prototypeOf(object)) {
				let fn = object[method]
				if (fn != this[method]) {
					return fn ? fn.apply(this, args) : undefined
				}
			}
		}
	}
	Processor: Controller {
		action: {
		}
		execute: (on, message) {
			let op = this.action[message.action]
			op && op.call(this, on, message)
		}
	}
	Owner: Controller {
		content: Control
		receive: (message) {
			message = messageFor.call(this, message)
			if (message.channel == "self") {
				this.controller.process(this, message)
				this.transmit.down(this, message)				
			} else {
				this.content.controller.process(this.content, message)
				this.transmit.down(this.content, message)
			}
		}
		transmit: {
			up: (on, signal) {
				while (on) {
					if (!signal.action) return
					on.receive && on.receive(signal)
					on = on.partOf
				}
			}
			//NB: down() is explicitly named because it is recursive.
			down: (on, signal) {
				if (on.part) for (on of on.part) {
					if (!signal.action) return
					on.receive && on.receive(signal)
					down(on, signal)
				}
			}
		}
		initialize: (conf) {
			conf.owner = this
			super.initialize(conf)
		}
	},
	Service: Object {
		service: (receiver, subject, request) {
			let message = this.createMessage(receiver, subject, request)
			this.process(receiver, message)
		}
		createMessage(receiver, subject, request) {
			let message = this.sys.extend()
			message.action = subject
			message.request = request
			message.status = 0
			return message
		}
		process: (receiver, message) {
			throw new Error("Abstract Service Call.")
		}
	},
	FileService: Service {
		open: (pathname, receiver) {
			this.service(receiver, "opened", {
				url: pathname,
				method: "GET"
			})
		}
		save: (pathname, content, receiver) {
			this.service(receiver, "saved", {
				url: pathname,
				content: content,
				method: "PUT"
			})
		}
	}
	Part: Object {
		@iterator: *() {
			const length = this.length
			if (length) {
				for (let i = 0 i < length i++) yield this[i]				
			} else {
				for (let name in this) yield this[name]				
			}
		}
	}
	Empty: Object {
		@iterator: *() {
		}
	}
	List: Object {
		@iterator: *() {
			for (let i = 0 i < this.length i++) yield this[i]
		}
	}
	Record: Object {
		@iterator: *() {
			for (let name in this) yield this[name]
		}
	}
}

private: {
	LAST_ID: 0
	
	messageFor: (signal) {
		let message = signal
		if (typeof message == "string") {
			message = this.sys.extend()
			message.action = signal
		}
		return message
	}
}