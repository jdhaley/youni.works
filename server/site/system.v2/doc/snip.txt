/*
		types: {
			String: "",
			Number: 0,
			Boolean: false,
			Date: new Date(0),
			Function: function() {
			},
			type$Object: "./Object",
			type$Array: "./Array",
			type$Parcel: "./Parcel",
			type$Record: "./Record",
			type$Instance: "./Instance",
		},
		falses: [undefined, NaN, 0, false, null, ""],
 */
//Interface: {
//	type$: Instance,
//	properties: OBJECT,
//	applyTo: function(object) {
//		let props = this.properties;
//		for (let name in props) props[name].define(object);
//	}
//},

//Property: {
//type$: Instance,
//name: "",
//source: undefined,
//declare: function(name, value) {
//	return this.sys.extend(this, {
//		name: name,
//		source: value,
//		configurable: true,
//		enumerable: true
//	});
//},
//compile: null,
//define: function(object, contextName) {
//	try {
//		if (this.compile) {
//			this.compile(contextName);
//			this.sys.define(this, "compile", undefined);
//			Object.freeze(this);
//		}
//		Reflect.defineProperty(object, this.name, this);
//	} catch (error) {
//		contextName = contextName ? contextName + "/" + this.name : this.name;
//		error.message = `When defining "${contextName}": ${error.message}`;
//		throw error;
//	}
//}
//},

//define: function(object, contextName) {
//	try {
//		Reflect.defineProperty(object, this.name, this);
//	} catch (error) {
//		contextName = contextName ? contextName + "/" + this.name : this.name;
//		error.message = `When defining "${contextName}": ${error.message}`;
//		throw error;
//	}
//}

//
//Function.prototype.super = function(thisArg, ...args) {
//	for (let proto = Object.getPrototypeOf(thisArg); proto; proto = Object.getPrototypeOf(proto)) {
//		let protoValue = proto[this.name];
//		if (protoValue !== this) {
//			if (typeof protoValue == "function") return protoValue.apply(thisArg, args);
//			break;
//		}
//	}
//	throw new Error(`super "${this.name}" is not a method.`);
//}
//option 3: a method$ facet puts super on the function.

