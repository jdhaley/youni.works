{
	"type": "object",
	"part": {
		"name": {
			"type": "string",
			"source": "youni.works/base/system"
		},
		"use": {
			"type": "object",
			"part": {
				
			},
			"constructor": "type"
		},
		"main": {
			"type": "function",
			"source": "function() {\r\n\t\tconst OBJECT = window.Object;\r\n\t\tconst INTERFACE = Symbol(\"interface\");\r\n\r\n\t\tconst Object = OBJECT.create(null);\r\n\t\tObject[Symbol.toPrimitive] = function(hint) {\r\n\t\t\tlet value = this.valueOf(hint);\r\n\t\t\t/*\r\n\t\t\t \tThe primitive value is determined recursively via '+value' and '\"\" + value'\r\n\t\t\t \twhen \"value\" is an object, unless \"value === this\" in which case we return \r\n\t\t\t \t1 (\"truth\") or \"\". There is a small risk of an endless loop when this.valueOf()\r\n\t\t\t \treturns another object whose value cycles back to this.\r\n\t\t\t */\r\n\t\t\tif (hint == \"number\") return value === this ? 1 : +value;\r\n\t\t\tif (hint == \"string\") return value === this ? \"\" : \"\" + value;\r\n\t\t\treturn value[Symbol.toStringTag];\r\n\t\t}\r\n\t\tObject.valueOf = function(type) {\r\n\t\t\treturn type == \"function\" ? this.apply.bind(this) : this;\r\n\t\t}\r\n\t\tObject.apply = function apply() {\r\n\t\t\tlet value = arguments.length ? this[arguments[0]] : this;\r\n\t\t\tif (arguments.length > 1) {\r\n\t\t\t\tif (typeof value != \"function\") {\r\n\t\t\t\t\tthrow new TypeError(`\"${arguments[0]}\" is not a function.`);\r\n\t\t\t\t}\r\n\t\t\t\tvalue = value.apply(this, arguments[1]);\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\tconst Declaration = OBJECT.create(Object);\r\n\t\tDeclaration.define = function(object) {\r\n\t\t\treturn OBJECT.defineProperty(object, this.name, this);\r\n\t\t}\t\t\r\n\t}"
		},
		"public": {
			"type": "object",
			"part": {
				"Object": {
					"facet": "type",
					"type": "string",
					"source": "Object"
				},
				"Declaration": {
					"facet": "type",
					"type": "string",
					"source": "Declaration"
				},
				"System": {
					"type": "object",
					"part": {
						"undefined": {
							"facet": "super",
							"type": "string",
							"source": "Object"
						},
						"prototypeOf": {
							"type": "function",
							"source": "function(value) {\r\n\t\t\t\tif (value && typeof value == \"object\") return OBJECT.getPrototypeOf(value);\r\n\t\t\t}"
						},
						"interfaceOf": {
							"type": "function",
							"source": "function(value, name) {\r\n\t\t\t\twhile (value) {\r\n\t\t\t\t\tvalue = value && value[INTERFACE];\r\n\t\t\t\t\tif (!name) return value;\r\n\t\t\t\t\tif (name == value[Symbol.toStringTag]) return value;\r\n\t\t\t\t\tvalue = this.prototypeOf(value);\r\n\t\t\t\t}\r\n\t\t\t}"
						},
						"isPrototypeOf": {
							"type": "function",
							"source": "function(object, value) {\r\n\t\t\t\treturn typeof object == \"object\" \r\n\t\t\t\t\t? OBJECT.isPrototypeOf.call(object, value)\r\n\t\t\t\t\t: false;\r\n\t\t\t}"
						},
						"isInterface": {
							"type": "function",
							"source": "function(object) {\r\n\t\t\t\treturn this.hasOwn(object, INTERFACE) || object === Object;\r\n\t\t\t}"
						},
						"isDeclaration": {
							"type": "function",
							"source": "function(value) {\r\n\t\t\t\treturn this.isPrototypeOf(Declaration, value);\r\n\t\t\t}"
						},
						"isPublic": {
							"type": "function",
							"source": "function(object, key) {\r\n\t\t\t\tfor (; object; object = this.prototypeOf(object)) {\r\n\t\t\t\t\tlet descriptor = Reflect.getOwnPropertyDescriptor(object, key);\r\n\t\t\t\t\tif (descriptor) return descriptor.enumerable ? true : false;\r\n\t\t\t\t}\r\n\t\t\t\treturn undefined;\r\n\t\t\t}"
						},
						"describe": {
							"type": "function",
							"source": "function(object, key) {\r\n\t\t\t\twhile (object) {\r\n\t\t\t\t\tlet descriptor = Reflect.getOwnPropertyDescriptor(object, key);\r\n\t\t\t\t\tif (descriptor) {\r\n\t\t\t\t\t\tdescriptor.name = key;\r\n\t\t\t\t\t\tdescriptor.definedOn = object;\r\n\t\t\t\t\t\treturn this.extend(Declaration, descriptor);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tobject = this.prototypeOf(object);\r\n\t\t\t\t}\r\n\t\t\t\treturn Declaration;\r\n\t\t\t}"
						},
						"hasOwn": {
							"type": "function",
							"source": "function(object, key) {\r\n\t\t\t\treturn object && typeof object == \"object\" && OBJECT.hasOwnProperty.call(object, key);\r\n\t\t\t}"
						},
						"extend": {
							"type": "function",
							"source": "function(object, declarations) {\r\n\t\t\t\tif (!arguments.length) object = null;\r\n\t\t\t\treturn this.implement(OBJECT.create(object), declarations);\r\n\t\t\t}"
						},
						"implement": {
							"type": "function",
							"source": "function(object, declarations) {\r\n\t\t\t\tfor (let name in declarations) {\r\n\t\t\t\t\tthis.define(object, name, declarations[name]);\r\n\t\t\t\t}\r\n\t\t\t\treturn object;\r\n\t\t\t}"
						},
						"define": {
							"type": "function",
							"source": "function(object, name, decl) {\r\n\t\t\t\tif (!this.isDeclaration(decl)) {\r\n\t\t\t\t\tdecl = this.declare(decl, name);\r\n\t\t\t\t\tdecl.enumerable = true;\r\n\t\t\t\t\tdecl.writable = true;\r\n\t\t\t\t\tdecl.value = decl.source;\r\n\t\t\t\t}\r\n\t\t\t\ttry {\r\n\t\t\t\t\tdecl.define(object);\r\n\t\t\t\t} catch (error) {\r\n\t\t\t\t\tthis.error(error);\r\n\t\t\t\t}\r\n\t\t\t\treturn decl;\r\n\t\t\t}"
						},
						"defineInterface": {
							"type": "function",
							"source": "function(object, name) {\r\n\t\t\t\tif (!object.sys) object.sys = this;\r\n\t\t\t\tif (name) OBJECT.defineProperty(object, Symbol.toStringTag, {value: name});\r\n\t\t\t\tif (this.isInterface(this.prototypeOf(object))) {\r\n\t\t\t\t\tOBJECT.defineProperty(object, INTERFACE, {value: object});\r\n\t\t\t\t}\r\n\t\t\t}"
						},
						"declare": {
							"type": "function",
							"source": "function(source, name, facet) {\r\n\t\t\t\tlet prop = this.extend(Declaration);\r\n\t\t\t\tif (name) prop.name = name;\r\n\t\t\t\tif (facet) prop.facet = facet;\r\n\t\t\t\tprop.source = source;\r\n\t\t\t\treturn prop;\r\n\t\t\t}"
						},
						"error": {
							"type": "function",
							"source": "function(error) {\r\n\t\t\t\t//TODO could add a debugger statement when environment is development.\r\n\t\t\t\tthrow error;\r\n\t\t\t}"
						},
						"packages": {
							"type": "object",
							"part": {
								
							},
							"constructor": "type"
						}
					},
					"constructor": "type"
				}
			},
			"constructor": "type"
		}
	},
	"constructor": "type"
}