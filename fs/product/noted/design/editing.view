<div contenteditable="true" tabindex="1" class="body-part"><h1>Editing Approach</h1><div><span style="font-family: sans-serif;">I've had enough of document.execCommand &amp; content editable.</span></div><div><ul><li><span style="font-family: sans-serif;">We may not need content editable for monitoring selection changes:</span></li><ul><li>I believe selectionChange fires when you drag and create a selection.</li><li>There is no caret (collapsed selection).&nbsp; However, that is fine - I can track click/mousedown and translate the co-ordinate to a range.&nbsp; To display the caret, we just need a floating "blink" element.</li><li>To cut/copy/paste I believe contentEditable&nbsp;<span style="font-style: italic;">is&nbsp;</span>required.&nbsp; However, I may be able to switch on contentEditable only for the duration of the event.</li></ul><li>I need to build a command buffer with undo &amp; redo.&nbsp; Most of that is fairly straightforward because there's really only two commands:</li><ul><li>ReplaceRange:</li><ul><li>DO/REDO: Given a non-collapsed selection,record the range and the current content then replace it with some HTML.</li><li>UNDO: Given the range in the command, set the selection and replace it with the HTML in the command.</li></ul><li>ReplaceText:&nbsp; Given a collapsed range in a text node, determine the new text based on the {character, backspace, delete}.&nbsp; Check if the last command in the buffer is a SetText on the same text node:</li><ul><li>yes: set the command state to the new text (you don't undo/redo multiple text changes - you have "before text changes" and "after text changes".)</li><li>no: insert the command into the buffer with the prior text and the new text as state.</li></ul></ul><li>The complexity of the commands is relating the range "coordinates" to elements that get deleted.&nbsp; For example, the parent node is cleared and therefore the range becomes non-representative.&nbsp; I need to come up with a simple means to track the "range coordinate deltas" that isn't going to kill the browser with too much state being recorded.&nbsp; Ideally, the command state would be serializable and can therefore be pushed to the server so that a COMPLETE transcript of a document's state changes could be recorded with a "save" (such as in a full audit).</li></ul><br></div></div>